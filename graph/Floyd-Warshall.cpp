/*
Floyd-Warshall algorithm
최단경로를 구하는 모든 쌍 알고리즘

두 정점 u,v를 잇는 경로가 있을때 이 경로는 항상 u,v를 지나고, 거기에 더해서 다른 점들을 거쳐서
도달할 수 도 있어 이러한 점들을 경유점이라고 하자

정점 집합 S에 포함된 정점만을 경유점으로 사용해서 u->v로 가는 최단경로를 D{s}(u,v)라고 하자

최종적으로 원하는 값은 그렇게 되면 D{V}(u,v)가 된다 (V가 그래프의 모든 정점집합이라고 한다면)
두 정점을 잇는 가장 적은 간선을 쓰는 경로는 D{}(u,v)가 되겠지용(둘이 직접 연결)

만약 한 경로가 정점 x를 경유하지 않는다면
u->v로 가는 최단경로에는 S-{x} 정점만을 경유점으로 하여 구할 수 있다

만약 이 경로가 x를 경유한다면
이 경로를 u->x , x-> v를 가는 구간으로 나누어 생각할 수 있고 두 구간 모두 최단경로여야지 u->v로 가는 최단경로임을 알 수 있다.

즉 따라서 재귀적으로 생각한다면
D{s}(u,v) = min( D{s-{x}}(u,x) + D{s-{x}}(x,v), D{s-{x}}(u,v) ) 가 된다 ( 오른쪽께 첫번째 말한 경우)

위의 점화식을 조금 변경해서
S{k}를 {0,1,2,...,k}라고 하고 C{k} = D{S{k}}라고 하자
즉 C{k}(u,v)는 0번 ~ k번 정점을 경유점으로 하여 u->v로 가는 최단경로의 길이 가 된다.

C{k}(u,v) = min(C{k-1}(u,k) + C{k-1}(k,v), C{k-1}(u,v) ) 가 된다.
즉 C{k}의 값을 구할때는 C{k-1}의 값만있으면 됨을 알 수 있다.
*/
#include <algorithm>
using namespace std;
const int MAX_V = 1000;
//정점의 수
int V;

//그래프의 인접행렬 표현
//adj[u][v] = u -> v로 가는 간선의 가중치, 둘이 연결되지 않는다면 엄청 큰 수 를 넣는다.
int adj[MAX_V][MAX_V];
int C[MAX_V][MAX_V][MAX_V];
void allPairShortestPath1() {
	//C[0]를 초기화 기저사례
	for (int i = 0; i < V; ++i) {
		for (int j = 0; j < V; ++j) {
			if (i != j)
				C[0][i][j] = min(adj[i][j], adj[i][0] + adj[0][j]);
			else
				C[0][i][j] = 0;		//자기 자신으로 가는 정점은 최단거리가 0이다.
		}
	}

	//C[k-1]이 있다면 C[k]를 구할 수 있다.
	for (int k = 1; k < V; ++k) {
		for (int i = 0; i < V; ++i) {
			for (int j = 0; j < V; ++j) {
				C[k][i][j] = min(C[k - 1][i][j], C[k - 1][i][k] + C[k - 1][k][j]);
			}
		}
	}
}

//시간복잡도 O(|V|^3) 이고 메모리 사용량도 O(|V|^3)이다

//여기서 메모리 사용량을 줄이기 위해서는 위에서 보이듯이 C{k}의 값은 단지 C{k-1}의 값만이 필요할 뿐
//C{k-2}, C{k-3}...은 필요하지 않다. 따라서 이를 가지고 갈 필요가 없으므로 C{k}(u,v)의 값을 C{k%2}[u][v]에 다가 저장해준다. (0,1이 반복되면서 두개만을 가지고간다)

/*
여기서 인접행렬을 바로 이용하는 방법이 생기는데
C{k}(u,v)를 계산할때는 C{k-1}(u,v)와 C{k-1}(u,k),C{k-1}(k,v)가 필요함을 알 수 있다.
이때 C{k-1}(u,k)와 C{k}(u,k)를 비교해보면
첫번째것은 0~k-1번 정점을 이용해서 u->k로 가는 최단거리이고
두번쨰는 0~k번 정점을 이용해서 u->k로 가는 최단거리이다
즉 k번 정점이 경유점에 사용되느냐 안되느냐의 차이는 존재하지 않는다(k가 시작점이거나 도착점인경우에는)
즉 C{k%2}와 C{(k-1)%2}를 구분할 필요가 없다. C{k-1}(u,k)와 C{k-1}(k,v)를 구하는 경우에 !

따라서 2차원 배열에 그냥 두고 (k의 값을 따로 잡아두지 않고 심지어 위에서 말했듯이 0,1로 구분도 필요없다. 왜냐면 둘은 차이가 없기 때문이지)
*/

int V;
int adj[MAX_V][MAX_V];

void floyd() {
	for (int i = 0; i < V; ++i)
		adj[i][i] = 0;

	for (int k = 0; k < V; ++k) {
		for (int i = 0; i < V; ++i) {
			for (int j = 0; j < V; ++j) {
				adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);		//왜냐면 k-1일때나 k일때나 adj[i][k]와 adj[k][j]는 같기 때문이고 (즉 adj[k-1][i][k] + adj[k-1][k][j] == adj[k][i][k] + adj[k][k][j] 이다)
				//오른쪽 min에서 adj[i][j]는 adj[k-1][i][j]와 같은 역할을 해 (왼쪽의 adj[i][j]가 adj[k][i][j]일텐데 대입 구문이니깐 아직 계산이 안된거야 즉 오른편의 adj[i][j]는 adj[k-1][i][j]값을 가지고 있어
			}
		}
	}
}

//이렇게 되면 시간복잡도는 그대로 O(|V|^3)이지만 메모리 사용량이 O(|V|^2)으로 줄어들었다.


/*
이렇게 플로이드 알고리즘으로 구한 최단경로의 실제 경로를 구하는 방법은

마지막으로 adj[u][v]를 갱신할때 사용된 k정점을 이용하면 되는데
이 k정점의 의미는 u->v로 가는 최단경로에는 k번 정점을 반드시 경유해서 간다는 의미가 된다.

그러므로 u->k로 가는 최단경로와 k->v로 가는 최단경로를 합쳐주면 u->v로 가는 최단경로를 만들어 낼 수 있다
이는 재귀적으로 구현할 수 있다.
*/
#include <vector>
using namespace std;

int V;
int adj[MAX_V][MAX_V];

int via[MAX_V][MAX_V];		//via[i][j] =i->j로 가는 최단경로가 경유하는 점중에 정점번호가 가장 큰 값을 집어넣는다. (-1로 초기화) (왜냐면 k가 0번부터 올라가면서 계산했기 때문에 마지막에 갱신된 k는 경유점중에 가장 큰 정점번호를 갖는다.)

void floyd2() {
	for (int i = 0; i < V; ++i)
		adj[i][i] = 0;

	memset(via, -1, sizeof(via));
	for (int k = 0; k < V; ++k) {
		for (int i = 0; i < V; ++i) {
			for (int j = 0; j < V; ++j) {
				//이번에는 k번 정점에서 갱신이 된건지 안된건지를 체크하는 if문이 들어갔다.
				//즉 k번 정점을 경유해서 최단경로가 만들어지는건지를 본다.
				if (adj[i][j] > adj[i][k] + adj[k][j]) {
					via[i][j] = k;
					adj[i][j] = adj[i][k] + adj[k][j];		//위에서의 min함수를 쪼개서 쓴것!	adj[i][j]에 한번에 갖고가니깐 else인 경우에 adj[i][j]를 그대로 가져가니깐 따로 쓸필요 없당.
				}
			}
		}
	}
}

//u->v로 가는 최단경로를 구해서 path에 저장한다.
void reconstruct(int u, int v, vector<int>& path) {
	//기저사례
	if (via[u][v] == -1) {
		//u->v로 가는 친구사이에 경유점이 없다면 직접 연결된거야 혹은 자기자신으로 가는경로
		path.push_back(u);
		if (u != v)
			path.push_back(v);
	}
	else {
		int w = via[u][v];
		reconstruct(u, w, path);
		path.pop_back();		//w가 위에서 한번 밑에서 한번 들어갈테니깐 중복을 제거한다.
		reconstruct(w, v, path);
	}
}



/*
플로이드를 이용해서는 가중치 없는 그래프에서 각 정점쌍에 대해서 도달가능성에 대해서 구할 수 있다.
즉 모든 정점 쌍 u,v에 대해서 u->v인 경로가 존재하는지를 조사한다.
위에서의 C{k}(u,v)를 0~k번 정점을 경유해서 u->v로 도달할수 있는지의 여부 로 바꾼다면 (bool값으로)
C{k}(u,v) = C{k-1}(u,v) || (C{k-1}(u,k) && C{k-1}(k,v))로 얻을 수 있다.!
*/