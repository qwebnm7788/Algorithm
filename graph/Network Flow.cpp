/*
Network Flow (네트워크 유량)

그래프에서 각 간선이 길이가 아닌 용량으로 표현되었을 경우를 살펴보자
이 때 각 간선들은 "용량"이라는 값을 가지게 되는데 (거리가 아니라) 이런 그래프에서
각 경로를 따라서 보낼 수 있는 용량을 정하는 일을 할 수 있다.
이러한 용량을 갖는 그래프에서 두 정점사이에 얼마나 많은 흐름(유량(flow))을 보낼 수 있는 지를 계산하는
문제를 네트워크 유량(Network flow)문제라고 한다.
*/

/*
우선 유량 네트워크(flow network)란 각 간선에 용량(capacity)라는 속성이 부여된 방향(directed)그래프를 말한다.
정점 u에서 v로 가는 간선의 용량을 c(u,v), 실제 흐르는 유량(flow)를 f(u,v)라고 하면
다음과 같은 속성을 항상 만족해야 한다.
1. f(u,v) <= c(u,v) -> 즉 각 간선에 흐르는 유량은 최대 그 간선의 용량까지밖에 안된다 (초과할 수 없다)
2. f(u,v) = -f(v,u) -> u->v로 유량이 흐르면 그 반대로는 크기가 같은 음의 유량이 흐른다 (대칭성)
3. 각 정점에 연결된 간선의 총 유량의 합은 0이 되어야 한다. (즉 들어오는 유량의 합과 나가는 유량의 합이 같아야한다. (2번의 대칭성에 의해 들어오는 유량은 음수로 표현되고 나가는 유량과 "크기"는 동일하므로)

유량 네트워크에는 source와 sink가 있는데
source 는 유량이 시작되는 정점이고 sink는 유량이 도착하는 정점이다.
물론 이때 source와 sink에서는 위에서의 3번 속성이 성립하지 않는다. source에서는 나가기만 하고 sink에서는 들어오기만 해야되니깐
*/


/*
네트워크 유량문제를 푸는 방법에는 여러 종류가 있지만 가장 간단한 방법으로 포드-풀커슨 알고리즘(Ford-Fulkerson algorithm)이 있다.

네트워크의 모든 간선의 유량을 0으로 두고 시작해서 source -> sink로 유량을 더 보낼 수 있는 경로를 찾아내서 유량을 보내는 과정을 반복하는 것이다.

유량을 보낼 수 있는 경로를 증가경로(Augmenting path)라고 부른다.
또한 유량을 보낼 수 있다는 말은 한 간선에 이미 흐르는 유량외에도 추가로 보낼 수 있는 여유 용량이 있다는 말이 되는데
이 여유 용량은 (간선의 용량 - 간선에 현재 흐르는 유량)으로 구할 수 있고 이 값을 잔여용량(residual capacity)라고 부른다.
잔여 용량을 r(u,v)라 하면 r(u,v) = c(u,v)-f(u,v)이다.

이때 증가경로를 통해서 보낼 수 있는 유량의 최대값은 이 경로에 포함된 간선의 잔여용량중에 가장 작은 값이 된다. (그것보다 크면 그보다 작은 간선에는 유량을 흘릴 수 없게 되서 이 경로는 증가경로가 안되게 된다.)

포드-풀커슨 알고리즘은 이렇게 증가경로가 더이상 존재하지 않을때까지 증가경로를 찾아서 보낼 수 있는 최대 유량을 흘려보내는 작업을 반복한다.
증가경로를 찾는 과정은 그래프 탐색 알고리즘(DFS,BFS등)을 이용하면 된다.
*/

/*
만약 한 증가경로를 고르므로써 아직 최대유량을 찾지 못했는데 모든 증가경로를 찾았다면 어떡하지?

-> 그래서 위의 유량 네트워크의 2번속성이 존재하는 것!
만약 a->b간선만 있고 b->a 간선은 없는 경우를 생각해보자 그렇게 되면 용량 c(b,a) = 0이야 (없으니깐) 그런데
근데 f(a,b) = 1이라고 하면 2번 속성(유량의 대칭성)에 의해서 f(b,a) = -1이 된다. 그러면 r(b,a) = c(b,a)-f(b,a) = 0 - (-1) = 1이 되어서
b->a로 1만큼의 유량을 흘려보낼 수 있는 상태가 되어버린다.

이 의미는 무엇일까?
이렇게 되면 a->b로 1만큼의 유량을 주고 다시 b->a로 1만큼의 유량을 준것이 되어 버린다.
즉 이렇게 되면 a에서는 b쪽으로 유량을 주지 않은것으로 바뀌는거야 그러면 a에서 b쪽이 아니라 다른 쪽으로 1만큼을 더 흘려줄 수 있는 여유가 생기게 되어서
다른 증가경로를 탐색 할 수 있는 방법이 생기게 된 것이다.

따라서 새 유량을 흘리는 것과 기존의 유량을 상쇄시키는 것은 같은 의미가 된다 (기존의 것쪽으로가 아니라 다른 쪽으로 보내는 것과 같기 때문이지)
*/

/*
포드-풀커슨 알고리즘의 구현은 우선 증가경로를 BFS를 이용해서 찾고 가능한 최대유량을 흘려준다.
이러한 과정을 더 이상의 증가경로가 없을때까지 반복해준다.
*/


#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

const int INF = 987654321;
const int MAX_V = 1000;

int V;

//capacity[u][v] = u-> v로 보낼 수 있는 용량
//flow[u][v] = u->v로 흐르는 현재 유량(반대 방향일 때는 음수로 저장)
int capacity[MAX_V][MAX_V];
int flow[MAX_V][MAX_V];

//flow[][]를 계산하고 보낼수 있는 최대유량(max-flow)를 반환한다.
int networkFlow(int source, int sink) {
	//flow를 0으로 초기화
	memset(flow, 0, sizeof(flow));
	int totalFlow = 0;
	while (true) {
		//증가경로를 찾을 때까지 계속 반복
		//BFS로 증가경로 탐색
		vector<int> parent(MAX_V, -1);		//경로를 저장하기 위해서 바로 직전 정점을 저장
		queue<int> q;
		parent[source] = source;		//시작정점 표시
		q.push(source);
		while (!q.empty() && parent[sink] == -1) {
			//아직 sink에 도달하지 못했고, 큐에 방문예정 정점이 있는 동안 반복
			int here = q.front();
			q.pop();
			for (int there = 0; there < V; ++there) {
				//간선을 이용해야 하므로 모든 정점을 검사한다. capacity가 적절하게 초기화 되어 있어야 겠죠?
				if (capacity[here][there] - flow[here][there] > 0 && parent[there] == -1) {
					//잔여용량이 남아있고 아직 방문하지 않은 정점 탐색
					q.push(there);
					parent[there] = here;
				}
			}
		}
		
		//증가경로를 못찾으면 종료
		if (parent[sink] == -1)
			break;

		//이제 증가경로에서 최소의 잔여용량을 찾아서 그만큼 흘려준다.
		int amount = INF;
		for (int p = sink; p != source; p = parent[p]) {
			amount = min(capacity[parent[p]][p] - flow[parent[p]][p], amount);
		}

		//유량을 amount만큼 흘린다.
		for (int p = sink; p != source; p = parent[p]) {
			flow[parent[p]][p] += amount;		//원래의 경로는 parent[p] => p 순서이므로 그 방향으로 유량이 흐른다.!
			flow[p][parent[p]] -= amount;		//역방향으로는 음의 유량을 흘려준다.
		}

		totalFlow += amount;
	}

	return totalFlow;
}


/*
증가경로가 여러개일 때 아무거나 선택해도 최대 유량을 찾을 수 있는 증가경로가 되는가?
-> 최소 컷 최대 유량 정리(Min-cut Max-flow Theorem)을 이용하여 증명할 수 있다.

컷(cut)이란 유량네트워크에서 source와 sink가 서로 다른 집합에 속하도록 그래프의 정점을 두개의 집합으로 나눈 것이다.
source가 속한 집합을 S sink가 속한 집합을 T라고 하자

그러면 S -> T로 가는 간선의 "용량"의 총합을 컷 S,T의 용량이라고 하고
S->T로  실제로 보내는 유량의 총 합을 컷 S,T의 유량이라고 정의한다.
(이때 T->S로 들어오는 유량은 음수로 하여 계산할 수 있다. (S->T로 음수로 나간다고 볼수 있기 때문)

이때 이러한 컷의 속성을 살펴보자
1. 컷의 유량은 source->sink 로 가는 "총 유량"과 같다.
왜냐면 네트워크의 모든 유량은 source-> sink로 흘러들어가기 때문(이것이 유량의 정의 였기 때문이지)
그러므로 무조건 모든 유량은 S->T의 간선을 이용하게 되므로 여기에 흐르는 유량과 같다.
또한 T->S로 흐르는 유량을 음수로 계산하기 때문에 우리가 구한 네트워크의 유량중에 S,T 사이를 여러번 오가는 친구들도
계산해 낼 수 있다.

2.컷의 유량은 컷의 용량보다 작거나 같다. 왜냐면 이것은 유량 네트워크의 기본성질로써 모든 간선에 대해서 유량은 용량보다 작거나 같다가 성립하기 때문에
이렇게 집합으로써 봐도 동일하게 적용된다.

따라서 모든 컷(S,T를 어떻게 잡느냐에 따라 컷이 여러개가 될 수 있다.)의 유량은 동일하다(네트워크에 흐르는 "총 유량"으로 동일)
또한 어떤 컷에서라도 그 컷의 용량은 유량 "이상"의 값을 갖는다.
이때 용량이 가장 작은 컷을 찾는 문제를 최소 컷(min cut)문제 라고 한다.
*/

/*
Min-cut 문제를 해결 하는 방법은 Max-flow를 찾는 문제와 연관되어 있다.

만약 용량 = 유량인 컷 S,T가 존재한다고 가정하자
그러면 컷 S,T는 항상 min-cut 이고 source->sink로 보내는 유량은 네트워크의 최대 유량(max-flow)임을 보일 수 있다.

컷 S,T보다 용량이 작은 컷이 존재한다면 (용량 = 유량이므로) 그 유량보다 작은 용량을 갖는 컷이 존재한다는 것인데
위의 1번에 의해서 모든 컷의 유량은 동일하다 -> 그렇게 되면 그 작은 컷은 유량보다 더 작은 용량을 갖게 된다는 것인데
이것은 모순이 생기므로 있을 수 없다.

이보다 더 많은 유량을 흘릴 수 있다면 컷 S,T는 용량보다 더 많은 양의 유량을 흘려야 되니깐 이것 또한 모든 컷에 대해서 유량이 "총 유량"으로 동일한데
이 때는 모순이 된다(용량보다 더 많은 유량을 흘릴 수 없으므로)

*/

/*
그러면 어떻게 하면 유량=용량인 컷을 찾아낼까

증가경로가 더이상 존재하지 않는 경우에 이러한 컷을 찾아내는 방법은
증가경로가 더 없는 상태에서 source에서 잔여용량이 있는 간선을 통해서 갈 수 있는 정점들의 집합 S와 그럴 수 없는 집합 T으로 나누는 것이다.
이렇게 분류하면 우선 source는 S에 항상 속할 것이고 증가경로가 없으므로 sink까지는 도달 하지 못하므로
sink는 항상 T에 속하게 될 것이야 그렇게 만든 S, T는 항상 컷이 된다.

이 때 S-> T로가는 모든 간선의 잔여용량은 0이야 왜냐면 잔여용량이 1이라도 있으면 그 정점은 S에 속해야 겠죠? T가 아니라 (위에서 나눈 기준에 의해서 (잔여 용량이 있어서)도달 가능한 점은 모두 S에 있으므로)
즉 그러므로 잔여용량이 모두 0이라는 말은 모든 간선이 용량 == 유량이 되었다는 소리야
따라서 우리가 찾는 용량==유량인 컷을 찾게 된거야

포드-풀커슨 알고리즘은 증가경로가 더이상 존재하지 않으면 종료하게 되니깐
이 때 찾아낸 유량은 네트워크의 최대유량이 됨을 알 수 있어 왜냐면 위에서 말했듯이 증가경로가 더이상 존재하지 않은 상태에서 흐르고 있는 유량의 총 합이
max-flow야 그 때 source에서 도달 가능한 친구를 S로 아닌 친구를 T로 나눈다면 min-cut임도 알 수 있고

따라서 포드-풀커슨 알고리즘으로는 max-flow도 구할 수 있고
min-cut문제도 해결할 수 있음을 알 수 있어.
*/

/*
시간복잡도
이 알고리즘은 우선 무한루프를 돌면서 증가경로가 끝날때까지를 찾아주어야 하는데
알 수 있는 사실은 증가경로를 하나 찾을때마다 전체 유량이 최소 1만큼은 증가한다는 사실이야(증가경로를 찾았다는 것은 흘릴 수 있는 유량이 있다는 것이고 그 값은 최소 1일테니깐 (정수로 치면))

그러면 이 그래프의 최대 유량이 f라고 하면 증가경로는 많아야 f개뿐일꺼야 (1씩 f번)
따라서 경로탐색에 드는 O(|V|+|E|)에 곱하게 되면 O(|E|f)의 시간복잡도를 가짐을 알 수 있다. (대부분의 경우에 |E| > |V| 이므로)

근데 만약 최대유량이 큰 경우라면 f가 커져서 꽤나 느려질 가능성이 생기게된다.
그런데 이 알고리즘은 BFS로 경로를 탐색하기 때문에 항상 최단경로로써 증가경로를 찾기 때문에 유량을 조금 쓰는 곳으로 돌아가는 친구들은 발견되지 않아
그래서 BFS로 포드-풀커슨 알고리즘을 사용하게 되면 최대 O(|V||E|)개의 증가경로만을 사용함이 알려져 있다. (증명은 ㅜㅜ)
따라서 시간복잡도는 min(O(|E|f), O(|V||E|^2)) 이 된다.

(BFS를 쓴 포드-풀커슨 알고리즘을 에드몬드-카프(Edmonds-Karp)알고리즘이라고도 한다.)
*/


/*
인접리스트를 이용해서 구현할 때 주의해야 할 점은
포드-풀커슨 알고리즘이 실제로 b->a로의 간선이 이어져 있지 않더라도 a->b가 있다면 음의 유량을 b->a로 보내는 일 있기 떄문이야

그래서 이때는 a->b 간선이 있다면 b->a로 가는 간선을 추가해주는데 이 간선의 용량은 0으로 만들어 둠으로써 유량을 상쇄할때만 사용가능하게 설정해 주면
해결 할수있다.

*/

//간선 구조체
struct Edge {
	int target;
	int capacity;
	int flow;

	//역방향 간선의 포인터
	Edge* reverse;

	//간선의 잔여용량 계산
	int residualCapacity() const {
		return capacity - flow;
	}

	//이 간선에 amt만큼 유량을 흘린다.
	void push(int amt) {
		flow += amt;
		reverse->flow -= amt;		//거꾸로는 음의 유량을 흘린다.
		//이때 reverse->push(-amt)를하면 그 속에서도 같은걸 계속 부르면서 무한루프에 빠질꺼야
	}
};

//인접리스트 표현
vector<Edge*> adj[MAX_V];
//u->v간선 추가
void addEdge(int u, int v, int capacity) {
	Edge* uv = new Edge();
	Edge* vu = new Edge();

	//u->v 간선의 초기화
	uv->target = v;
	uv->capacity = capacity;
	uv->flow = 0;
	uv->reverse = vu;

	//v->u간선의 초기화 (용량은 0)
	vu->target = u;
	vu->capacity = 0;
	vu->flow = 0;
	vu->reverse = uv;

	//각 정점에 대해서 나가는 간선만 추가.
	adj[u].push_back(uv);
	adj[v].push_back(vu);
}


/*
그래프 모델링!!

1.
마일리지와, 현금이 있을때 마일리지를 쓸수있는 사용처가 제한되어 있는 경우
이 둘을 적절히 조합하여서 현금을 최소로 쓸 수 있는 경우를 본다면 이 문제는 마일리지를 최대화 시키는 것과 같다.

source -> A -> B -> sink 로 모델링을 하면

A를 마일리지 종류의 집합을 정점으로 표현한 친구들이라고 하면
source-> A의 각 정점으로의 간선의 용량은 각 마일리지의 사용가능한 값이 된다.

A-> B는 그 마일리지가 사용될 수 있는 사용처로 연결되고 그 간선의 용량은 무한대가 된다.

B-> sink의 간선은 그 사용처의 가격을 용량으로 함으로써 

마일리지와 현금을 적절히 조화해서 최대 유량 (여기서 유량을 마일리지로 보았기 때문)을 구해주면 현금을 최소한으로 사용하여
돈을 쓰는 방법을 제시해 준다.




2.
정점을 컷으로 하는 문제는 어떻게 풀까? (간선을 컷으로 둔다면 그냥 min-cut 으로 풀 수 도 있을꺼야)

이때는 정점의 용량을 간선으로 변형시켜서 그래프를 모델링 하는 방법을 이용하면 된다.

--> 각 정점을 들어오는 정점 + 나가는 정점으로 분리시킨다. 즉 이 정점으로 들어오는 모든 간선은 들어오는 정점에 가게 만들고
이 정점에서 나가는 간선은 나가는 정점에서 출발하도록 만든다.
그리고 이 들어오는 정점 -> 나가는 정점 사이의 단방향 간선으로 연결해주고 이 간선의 용량을 이 정점의 용량으로 만들어 주면

이 정점에는 최대 그 용량만큼 흐를 수 있는 그래프로 바뀌게 된다.
*/