/*
Binary Search
이분탐색을 사용해서 parametric search 방법을 적용한다.
(parametric search란 어떤 정답을 구할때 수식을 적용해서 딱 답을 구하는것이 아니라
거꾸로 결과값을 미리 한번 찍어보고 이 결과가 옳은 것인지를 체크 하고 아니면 다른걸 넣어보는 이런방식의 탐색을 말한다.
거꾸로 결과값을 찍어볼때 linear search를 해볼수도 binary search를 해볼수도 있는거야

*/


/*
여기서는 답이 존재가능한 영역을 [0,20]이라고 잡았으면
왼쪽 끝(하한)은 정답이 가능한 최대의 값이고
오른쪽 끝(상한)은 정답이 불가능한 가장 작은 값이라고 하자.
그렇게 되면 이 두 영역 사이에는 반드시 정답이 존재할 것 이라고 생각할 수 있다.

이때 0과 20의 정가운데 값인 10이 정답인지를 체크해보고
조건이 만족된다면 범위를 [10,20]으로 줄여 -> 그래도 여전히 하한값은 조건을 만족하는 값이 됨을 알 수 있어
만약 조건을 만족하지 못했다면 범위를 [0,10]으로 줄이는데 여기서도 상한값은 조건을 만족하지 못하는 가장 작은 값임을 알 수 있어

이런식으로 줄어들면서 두 영역의 차이가 1이 되는 순간
정답이 구해지는데 이때의 하한값이 조건을 만족하는 최대의 값이 되는 것이고
상한값은 조건을 불만족하는 최소의 값이 되는 것이다. !
*/


#include <stdio.h>

int main() {
	int N, M, height[1000000000];
	scanf("%d %d", &N, &M);
	for (int i = 0; i < N; ++i)
		scanf("%d", height + i);

	//조건을 불만족하는 값인 hi는 가능한 최댓값으로 설정하고 시작하는 것이 좋다.
	int lo = 0, hi = 1000000000;

	//binary search
	//구간의 크기가 1이 될때까지
	while (lo + 1 < hi) {
		int mid = (lo + hi) / 2;

		//조건을 만족하는지의 여부를 검사한다.
		long long sum = 0;
		for (int i = 0; i < N; ++i)
			if (height[i] > mid)
				sum += height[i] - mid;

		//중간값이 조건을 만족한다면
		if (sum >= M)
			lo = mid;
		else
			hi = mid;		//조건을 불만족한다면
	}

	//원하는 정답은 조건을 만족하는 최대의 값이므로
	printf("%d\n", lo);
}

/*
여기서의 시간복잡도는 값이 가질 수 있는 최대값이 1000000000 이므로
이진탐색을 적용하므로 log(1000000000)번의 탐색이 이루어지고
매번 O(N)번의 조건 만족 검사가 진행되므로 O(N*log(1000000000))이 된다.
*/

/*
지금과는 달리 조건을 만족하는 최소의 값을 구하는 경우에는
하한값을 조건을 불만족하는 값으로 하고 상한값을 조건을 만족하는 값으로 설정한 뒤에
거꾸로 if~else문을 꾸며서 구해줄 수 도 있다.

또 이런 문제에서는 hi의 값이 상당히 클 수도 있고 이로 인해서 int형으로는 오버플로우가 생길 수 있다.
따라서 애매한 경우에는 long long 형을 사용하여 주면 된다.
*/